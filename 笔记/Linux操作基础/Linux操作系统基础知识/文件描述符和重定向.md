# 场景

1. 如何把本来输出在屏幕上的内容，保存到文件？
2. 怎么把后台运行的程序输出内容保存到文件？
3. 怎么把一个文件的内容作为一条命令的输入？
4. 怎么屏蔽命令运行中的错误信息？
# <font color="#0070c0">文件描述符 File Descriptor（系统自带）</font>

| ID  | 描述              | 设备  |       |
| --- | --------------- | --- | ----- |
| 0   | 标准输入 (stdin)    | 键盘  | 默认输入值 |
| 1   | 标准输出 (stdout)   | 显示器 | 默认输出值 |
| 2   | 标准错误输出 (stderr) | 显示器 |       |
# <font color="#0070c0">重定向符号解释</font>

| 符号         | 类别                                          |
| ---------- | ------------------------------------------- |
| `>` 和 `>>` | 输出重定向(1个是覆盖2个是追加)                           |
| `&>`       | 表示将一个流(stream)重定向到另一个文件描述符(file descriptor) |
| `<` 和 `<<` | 输入重定向(默认从键盘读取)                              |
## 重定向：改变输入输出的方向
# <font color="#0070c0">案例-输出重定向</font>

-tx-
| 类别        | 命令格式          |      示例                                                                 |
| :-------- | :----------------- | :----------------------------------------------------------------- |
| 标准输出重定向   | `command > file`   | `ls / 1>test.txt`（1可以省略）
|    ^^   | `command >> file`  |   `echo "wuya" 1>>test.txt`（1可以省略）       |                                                
| 标准错误输出重定向 | `command 2> file`  | `find / -name"aaa"2>err.txt`<br>`find / -name "aaa" 2>/dev/null` |
|    ^^   | `command 2>> file` | `find / -name "aaa" 2>>err.txt`                                    |
| 输出和错误重定向  |                    | `ls 7.txt 8.txt 1>a.txt 2>b.txt`                                   |
| ^^    |                    | `find / -name "aaa" >test.txt 2>&1`                                |

2>&1的含义：将标准错误输出重定向到标准输出，符号`>&`是一个整体，不可分开，分开后就不是上述含义了(就是将标准和错误信息都合并输入/输出)
2>1的写法其实是将标准错误输出重定向到名为"1"的文件里去了
# 案例-输入重定向

| 命令格式             | 说明                                    | 案例                                              |
| ---------------- | ------------------------------------- | ----------------------------------------------- |
| `command < file` | 将 `file` 文件中的内容作为 `command` 的输入（省略了0） | `wc -l < test.txt`<br />统计 `test.txt` 文件中有多少行文本 |
| `command < END`  | 从标准输入（键盘）中读取数据，直到遇见分界符 `END` 才停止      | `wc -l << END`<br />统计用户在终端输入的文本的行数             |
